as a new language , rust gains lots of attaction, there're also many projects, which historic using C as primary language ,
begin to migrate to rust (librsvg/curl/tor). The most interesting project is definitely "bring rust to linux kernel development". 
what makes it interesting does not only because it's driven by google (Google found support developers who're developing such project), 
but also rust may become first alternative programming language in kernel development, other than C.

Previously kernel development always written in C, there're some attempts to bring C++ in, but never success. although C++ can be
seen as C superset (from some ones' perspective), Linus personally hate it, he expressed many times "C++ is horrible language". Follows
the long mail list (https://lore.kernel.org/ksummit/CANiq72kF7AbiJCTHca4A0CxDDJU90j89uh80S3pDqDt7-jthOg@mail.gmail.com/) 
which to bring rust to kernel, we can find there is no exception this time.

This mail list starts at 2021-06-25, Linus (please note it is Linus Torlards, not Linus Walleij) keeps silent until 2021-07-07 , after
 Bart Van Assche brings up topic 'why C++ not in kernel'
 
 ```
 ...
 As a sidenote, I'm surprised that C++ is not supported for Linux kernel
code since C++ supports multiple mechanisms that are useful in kernel
code, e.g. RAII, lambda functions, range-based for loops, std::span<>
and std::string_view<>. Lambda functions combined with std::function<>
allow to implement type-safe callbacks. Implementing type-safe callbacks
in C without macro trickery is not possible.
```

and Linus came up with:
```
You'd have to get rid of some of the complete garbage from C++ for it
to be usable.

One of the trivial ones is "new" - not only is it a horribly stupid
namespace violation, but it depends on exception handling that isn't
viable for the kernel, so it's a namespace violation that has no
upsides, only downsides.

Could we fix it with some kind of "-Dnew=New" trickery? Yes, but
considering all the other issues, it's just not worth the pain. C++ is
simply not a good language. It doesn't fix any of the fundamental
issues in C (ie no actual safety), and instead it introduces a lot of
new problems due to bad designs.
```

then Bart Van Assche shows some C++ code that override new operator globally (I didn't posted them here)
to workaround the problem, and Linus replied:

```
The point is, C++ really has some fundamental problems. Yes, you can
work around them, but it doesn't change the fact that it doesn't
actually *fix* any of the issues that make C problematic.

For example, do you go as far as to disallow classes because member
functions are horrible garbage? Maybe newer versions of C++ fixed it,
but it used to be the case that you couldn't sanely even split a
member function into multiple functions to make it easier to read,
because every single helper function that worked on that class then
had to be declared in the class definition.

Which makes simple things like just re-organizing code to be legible a
huge pain.

At the same time, C++ offer no real new type or runtime safety, and
makes the problem space just bigger. It forces you to use _more_
casts, which then just make for more problems when it turns out the
casts were incorrect and hid the real problem.

So no. We're not switching to a new language that causes pain and
offers no actual upsides.

At least the argument is that Rust _fixes_ some of the C safety
issues. C++ would not.
```

Let's take Linus first argument about 'new operator'

userspace(none-kernel) programmer may be supprised by Linus POV, most language
(such as gc based java/c# or C++) design the library/runtime to work "magically"
when dealing with memory allocation(from kernel developer's POV) . for example in C++

```
std::string temp;
temp.push_back("I_am_very_long_string");
```
there is no explicit allocating call , but under the hood such code must allocate 
dynamic heap memory.  such code running in userspace is no big deal, it just said 
"I don't care about how memory come from,
just give me 1MB memory, or I will throw a OOM exception", and most
userspace program don't care about OOM exception, they just let it crash whole program. 
 this makes sense for most scenario, since most program is designed to work under
"normal" environment(say, with enough memory to finish the work), if such condition not 
satisified anymore, there's very little program can do to recover (suppose another leaking
program consumed all the memory, leads your program memory allocation failed, only way to
recover functional is to kill the leaking program. but to do this, you still need memory 
allocation to list and find leaking one, thus OOM again and can't complete)


but this is not the case for Kernel.firstly there's no simple 'just gives me 1MB  memory' like malloc/new, 
kernel need to allocate memory with many flags depends on current running context, and secondly if such allocation 
failed, you can not simply throw OOM exception and crash, not only because exception is
too heavyweighted to be included in kernel, but also because a sensible kernel should never crash,
even under extream OOM case. there're some workaround (for example allocate memory 
manually first, and then using placement new, or using nothrow new), but the second argument
is the real reason why Linus not accept C++ as kernel development language:

```
but it doesn't change the fact that it doesn't actually *fix* any of the issues that make C problematic
...
 At least the argument is that Rust _fixes_ some of the C safety issues. C++ would not.
```

and  Miguel Ojeda (who posted 'support rust in kernel' patches) followed

```
The thing is, claims such as "C++ is as safe as Rust, you just need to
use modern C++ properly!" are still way too common online, and many
developers are unfamiliar with Rust, thus I feel we need to be crystal
clear (in a thread about Rust support) that it is a strict improvement
over C++, and not a small one at that.
```

so what's the issue that makes C problematic ?
short answser is memory safety, C is so bare-metal that it almost didn't forbit any incorrect semantic
code, for kernel development, it brings easily low-level access, but also too easy to code correctly,
 even for the most intellegent people who use it to do years kernel developing. 
 
 I grep the kernel git log from 2.6.12-rc2(2005-Apr 1da177e4c3f) to about 5.13-rc6 (2021-Jun 6b00bc639) by
```
git log --grep=leak --grep=error --all-match --oneline | wc -l
```
got 4626 result, you may also grep for "double free" (2234) or "use after free" (9987) to know how many memory 
safely bugs introduced and fixed in linux kernel. please note, some of these bugs are logic related ( 
even written in other languages it can still happen), but lack of memmory safety in C definitly be the cause
of most memory errors. as a side note, tor(which originally written in C) developers share their view 
in https://blog.torproject.org/announcing-arti
```
Since 2016, we've been tracking all the security bugs that we've found in Tor, and it turns out that 
at least half of them were specifically due to mistakes that should be impossible in safe Rust code
```


These catalog of bugs share a common property: they're so "trivial", even not being
kernel developer, we can easily understand why these piece of code is incorrect (with help of commit), 
and they're also so error-prone,even experience kernel developers continuous introduce such bugs. 
here I pick a leak fix as example

```
619fee9eb13 

 net: fec: fix the potential memory leak in fec_enet_init()

    If the memory allocated for cbd_base is failed, it should
    free the memory allocated for the queues, otherwise it causes
    memory leak.

    And if the memory allocated for the queues is failed, it can
    return error directly.

```

Let's pick the importand part out to see what happened:

code before fix:

```
        fec_enet_alloc_queue(ndev);
...
        cbd_base = dmam_alloc_coherent(&fep->pdev->dev, bd_size, &bd_dma,
                                       GFP_KERNEL);
        if (!cbd_base) {
               return -ENOMEM;
        }

```

code after fix:
```
        ret = fec_enet_alloc_queue(ndev);
        if (ret)
                return ret;

...

        cbd_base = dmam_alloc_coherent(&fep->pdev->dev, bd_size, &bd_dma,
                                       GFP_KERNEL);
        if (!cbd_base) {
                ret = -ENOMEM;
                goto free_queue_mem;
        }
...
free_queue_mem:
       fec_enet_free_queue(ndev);
       return ret;

```

seems easy to fix, right ? code have two allocations, but forget to deallocate first one if the 
second allocation failed. but the question is such leak is also easy to introduce, suppose similar
function need to allocate many times, such problem became harder. what makes it worse is maintainable,
since the cleanup function should be exactly same order as allocation (otherwise such cleanup table can't
be shared from different failure point), developer needs to be very careful to keep them
in sync when adjust order of allocation. break this rule may lead to leak/corruption/double free bugs.
RAII (as mentioned by Bart Van Assche), is C++ idom to address such problem, the trick is that destructor
will be run exactly when object exit scope, no matter if the scope is exited by normal control flow
or early error return. similar mechanisum (run function at scope exit) is borrowed by many other languages
for example java 1.7 try-with-resource, C# 8 using, go defer function, and also rust drop (some sort of),
even C commitee is looking into adding defer function to implement RAII like idom.
(http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2542.pdf)
From my personal view, before rust lang, I would say C++ destructor approach is the best to do automatic
resource management, better than Java/C# or go defer, I list my reasons here:

Java/C# early versions don't have such semantic, source management is done by try/catch/finally, 
new mechanism needs code migration, and force developer to make resource type inherit particular interface,
and again, developers can forget them, especially Java/C# being GC language. 


defer function have semantic confusions : 
the defer function defined point(in-between code) must be different to 
execute point (function end, or scope end), but what values do the argument used by defer function hold? 
do they 'capture' values at define point , or do they use most-written new value ? 
go prefer previous (https://tour.golang.org/flowcontrol/12)
```
The deferred call's arguments are evaluated immediately, but the function call is not executed until the surrounding function returns.
```
so 
```
    package main
    import "fmt"
    func main() {
         var a = "abc";
         defer fmt.Println("clean resource",a, "while running defer");
         a = "xyz";
         fmt.Println("resource is", a);
    }

```
will print 

```
resource is xyz
clean resource abc while running defer
```
 this policy implicits that
the variable which hold resource can't changed to point to new resource after
defer function defined(otherwise you're cleaning incorrect resource),
or you have to define new defer function everytime 
new resource is assigned.


C porposed defer function also have such confusions:

```
The results from 387 responses show a 2:1 preference for the value being read at the time the
deferred statements are executed (66.9%) rather than when the defer statement encountered (33.1%). One interesting thing to note is that of respondents who gave a rationale for their vote,
respondents known to have a strong C++ background seemed to gravitate towards using the
value when the defer statement is encountered, which suggests there may be some interesting
implicit bias.
A general solution to this problem is the introduction of lambdas to the C language [13] with both
copy and reference semantics. A more specific solution is to use a second defer statement
syntax which supplies an identifier list of variables to capture by value.

```

C++ RAII idom using constructor/destructor to acquire/release resource, acquired resource
kept as member, so it has no confusion during cleanup, and more important, resource management
auto keep sync as RAII object lifetime, makes the resource abstraction straightforward. 
this can implements simple "cleanup at scope exit" behaivor,
also can implement more flexiable resource management by manage RAII object lifetime .
for example

```
struct ComplexResource{
   .....
};

std::unique_ptr<ComplexResource> return_resource(){
   unique_ptr<ComplexResource> ret(new ComplexResource());
   .....
   return ret;
}

void use_resource(){
   unique_ptr<ComplexResource> resouce = return_resource();
   ...//use resource
   ...//at scope end,resource auto cleanup itself because unique_ptr cleanup its holding ComplexResource pointer
   ...//and ComplexResource auto cleanup its holding resource by ComplexResource destructor
}

```
use unique_ptr to extend ComplexResource lifetime, so resource can outlive scope it constructed, 
while still hold auto cleanup property (unique_ptr is also a RAII object which manage its holding pointer)

C++ RAII also have unique weakness, let's also talk about them. first is the C++ copy semantic,

if your ComplexResource is written as 
```
struct ComplexResource{
   void *resource;
};
```
then
```
unique_ptr<ComplexResource> resouce = return_resource();
ComplexResource temp = *source
```
lead a double free problem, because C++ use copy semantic,
temp var also holding resouce ,and they both try to cleanup same thing, twice.
this brings another confusing point: unique_ptr seems being copied multi times,
doesn't this also trigger double free bug  ? the answser is no,  unique_ptr
forbid copy so you won't copy unique_ptr even by accident
(thus it prevent unexpected copy to lead double free bug)
```
unique_ptr<ComplexResource> p1(new ComplexResource());
unique_ptr<ComplexResource> p2 = p1; //won't compile, error
```

but this raises other questions, if it can't be copied,
how can return_resource return it and why use_resource can assign returned value
from return_resource to variable ? the answser is C++ have many other 'tricky' rules,
these assignments is not 'copy', they're 'elision-copy' and 'move assignment',
which makes these code correct (although such rules doesn't match programmers 
straightforward view of code very much)

unique_ptr also have problems, C++ happily accept code like 
```
unique_ptr<ComplexResource> p1(new ComplexResource());
delete p1.get();
```
some C++ developer may argue that I shouldn't use manual delete on pointer
which managed by smart pointer, but unforunitely, such rule is not enforced by compiler
and real world codebase are much more complex, such error pair may be in completely
different files, not so easy to spot. especially when you have many legcy code which
only accept raw pointer.

now let's see why rust is different for auto resource management. at first,
its alike C++ RAII, constructor acquire resource, destructor (drop) cleanup it,
but rust non-POD (in C++ term) types use 'move semantic', which means
if assignment of RAII type in rust are always transfer (without C++ whole bunch
of dark rules), so another wrapper (unique_ptr in C++ example) to 
control RAII object lifetime is needless.and interesting part came for
manually object destroy, rust default destruct object at scope end, but if
you want to destroy object early, you call

```
ComplexResource resource = return_resource();
drop(resource);
```

firstly its alike calling destructor manullay or unique_ptr.reset,
but they're different, calling destructor manully on stack variable in C++
leads double free (alike) bugs, but rust
knows you don't need to run destructor again because you already drop it.
and this is also different to C++ unique_ptr.reset, since unique_ptr only
knows not to call destructor again because its internal pointer is null
at runtime, but rust knows such behaivor at compile time, without any runtime
bookmark ! and future more, in C++, you may access nullptr after reset unique_ptr
by acceident 
```
unique_ptr<ComplexResource> res= return_resource();
res.reset();
use_res_again(res);  // still compile, even incorrect
```

but rust compiler find your mistake at compile time!
```
ComplexResource res = return_resource();
drop(res);
use_res_again(res); ------------> rust won't compile, it tells you res already moved in drop call so you can't use it anymore
```
That 





