as a new language , rust gains lots of attaction, there're also many projects, which historic using C as primary language ,
begin to migrate to rust (librsvg/curl/tor). The most interesting project is definitely "bring rust to linux kernel development". 
what makes it interesting does not only because it's driven by google (Google found support developers who're developing such project), 
but also rust may become first alternative programming language in kernel development, other than C.

Previously kernel development always written in C, there're some attempts to bring C++ in, but never success. although C++ can be
seen as C superset (from some ones' perspective), Linus personally hate it, he expressed many times "C++ is horrible language". Follows
the long mail list (https://lore.kernel.org/ksummit/CANiq72kF7AbiJCTHca4A0CxDDJU90j89uh80S3pDqDt7-jthOg@mail.gmail.com/) 
which to bring rust to kernel, we can find there is no exception this time.

This mail list starts at 2021-06-25, Linus (please note it is Linus Torlards, not Linus Walleij) keeps silent until 2021-07-07 , after
 Bart Van Assche brings up topic 'why C++ not in kernel'
 
 ```
 ...
 As a sidenote, I'm surprised that C++ is not supported for Linux kernel
code since C++ supports multiple mechanisms that are useful in kernel
code, e.g. RAII, lambda functions, range-based for loops, std::span<>
and std::string_view<>. Lambda functions combined with std::function<>
allow to implement type-safe callbacks. Implementing type-safe callbacks
in C without macro trickery is not possible.
```

and Linus came up with:
```
You'd have to get rid of some of the complete garbage from C++ for it
to be usable.

One of the trivial ones is "new" - not only is it a horribly stupid
namespace violation, but it depends on exception handling that isn't
viable for the kernel, so it's a namespace violation that has no
upsides, only downsides.

Could we fix it with some kind of "-Dnew=New" trickery? Yes, but
considering all the other issues, it's just not worth the pain. C++ is
simply not a good language. It doesn't fix any of the fundamental
issues in C (ie no actual safety), and instead it introduces a lot of
new problems due to bad designs.
```

then Bart Van Assche shows some C++ code that override new operator globally (I didn't posted them here)
to workaround the problem, and Linus replied:

```
The point is, C++ really has some fundamental problems. Yes, you can
work around them, but it doesn't change the fact that it doesn't
actually *fix* any of the issues that make C problematic.

For example, do you go as far as to disallow classes because member
functions are horrible garbage? Maybe newer versions of C++ fixed it,
but it used to be the case that you couldn't sanely even split a
member function into multiple functions to make it easier to read,
because every single helper function that worked on that class then
had to be declared in the class definition.

Which makes simple things like just re-organizing code to be legible a
huge pain.

At the same time, C++ offer no real new type or runtime safety, and
makes the problem space just bigger. It forces you to use _more_
casts, which then just make for more problems when it turns out the
casts were incorrect and hid the real problem.

So no. We're not switching to a new language that causes pain and
offers no actual upsides.

At least the argument is that Rust _fixes_ some of the C safety
issues. C++ would not.
```

Let's take Linus first argument about 'new operator'

userspace(none-kernel) programmer may be supprised by Linus POV, most language
(such as gc based java/c# or C++) design the library/runtime to work "magically"
when dealing with memory allocation(from kernel developer's POV) . for example in C++

```
std::string temp;
temp.push_back("I_am_very_long_string");
```
there is no explicit allocating call , but under the hood such code must allocate 
dynamic heap memory.  such code running in userspace is no big deal, it just said 
"I don't care about how memory come from,
just give me 1MB memory, or I will throw a OOM exception", and most
userspace program don't care about OOM exception, they just let it crash whole program. 
 this makes sense for most scenario, since most program is designed to work under
"normal" environment(say, with enough memory to finish the work), if such condition not 
satisified anymore, there's very little program can do to recover (suppose another leaking
program consumed all the memory, leads your program memory allocation failed, only way to
recover functional is to kill the leaking program. but to do this, you still need memory 
allocation to list and find leaking one, thus OOM again and can't complete)


but this is not the case for Kernel.firstly there's no simple 'just gives me 1MB  memory' like malloc/new, 
kernel need to allocate memory with many flags depends on current running context, and secondly if such allocation 
failed, you can not simply throw OOM exception and crash, not only because exception is
too heavyweighted to be included in kernel, but also because a sensible kernel should never crash,
even under extream OOM case. there're some workaround (for example allocate memory 
manually first, and then using placement new, or using nothrow new), but the second argument
is the real reason why Linus not accept C++ as kernel development language:

```
but it doesn't change the fact that it doesn't actually *fix* any of the issues that make C problematic
...
 At least the argument is that Rust _fixes_ some of the C safety issues. C++ would not.
```

and  Miguel Ojeda (who posted 'support rust in kernel' patches) followed

```
The thing is, claims such as "C++ is as safe as Rust, you just need to
use modern C++ properly!" are still way too common online, and many
developers are unfamiliar with Rust, thus I feel we need to be crystal
clear (in a thread about Rust support) that it is a strict improvement
over C++, and not a small one at that.
```

so what's the issue that makes C problematic ?
short answser is memory safety, C is so bare-metal that it almost didn't forbit any incorrect semantic
code, for kernel development, it brings easily low-level access, but also too easy to code correctly,
 even for the most intellegent people who use it to do years kernel developing. 
 
 I grep the kernel git log from 2.6.12-rc2(2005-Apr 1da177e4c3f) to about 5.13-rc6 (2021-Jun 6b00bc639) by
```
git log --grep=leak --grep=error --all-match --oneline | wc -l
```
got 4626 result, you may also grep for "double free" (2234) or "use after free" (9987) to know how many memory 
safely bugs introduced and fixed in linux kernel. please note, some of these bugs are logic related ( 
even written in other languages it can still happen), but lack of memmory safety in C definitly be the cause
of most memory errors. as a side note, tor(which originally written in C) developers share their view 
in https://blog.torproject.org/announcing-arti
```
Since 2016, we've been tracking all the security bugs that we've found in Tor, and it turns out that 
at least half of them were specifically due to mistakes that should be impossible in safe Rust code
```


These catalog of bugs share a common property: they're so "trivial", even not being
kernel developer, we can easily understand why these piece of code is incorrect (with help of commit), 
and they're also so error-prone,even experience kernel developers continuous introduce such bugs. 
here I pick a leak fix as example

```
619fee9eb13 

 net: fec: fix the potential memory leak in fec_enet_init()

    If the memory allocated for cbd_base is failed, it should
    free the memory allocated for the queues, otherwise it causes
    memory leak.

    And if the memory allocated for the queues is failed, it can
    return error directly.

```

Let's pick the importand part out to see what happened:

code before fix:

```
        fec_enet_alloc_queue(ndev);
...
        cbd_base = dmam_alloc_coherent(&fep->pdev->dev, bd_size, &bd_dma,
                                       GFP_KERNEL);
        if (!cbd_base) {
               return -ENOMEM;
        }

```

code after fix:
```
        ret = fec_enet_alloc_queue(ndev);
        if (ret)
                return ret;

...

        cbd_base = dmam_alloc_coherent(&fep->pdev->dev, bd_size, &bd_dma,
                                       GFP_KERNEL);
        if (!cbd_base) {
                ret = -ENOMEM;
                goto free_queue_mem;
        }
...
free_queue_mem:
       fec_enet_free_queue(ndev);
       return ret;

```

seems easy to fix, right ? code have two allocations, but forget to deallocate first one if the 
second allocation failed. but the question is such leak is also easy to introduce, suppose similar
function need to allocate many times, such problem became harder. what makes it worse is maintainable,
since the cleanup function should be exactly same order as allocation (otherwise such cleanup table can't
be shared from different failure point), developer needs to be very careful to keep them
in sync when adjust order of allocation. break this rule may lead to new memory leak/corruption bugs.
In C++ world, RAII idom is used to address such problem. ideal behind RAII is that destructor is granted
to run at scope end, so you can put clean 


There're many new launguages poped in recent years, but linux kernel development have only a few options,  
it must be no GC, low leveled, and most importantly : much better than C. 

